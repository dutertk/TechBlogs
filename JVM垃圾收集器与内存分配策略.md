## 垃圾收集器与内存分配策略

### 对象已死吗？

垃圾收集器在对堆进行回收前，第一件事情就是要确定哪些对象还活着，哪些已经死去（即不可能再被任何途径使用的对象）

1. **引用计数算法**

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。

   但是主流的Java虚拟机里并没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。

2. **可达性分析算法**

通过一系列的称为“**GC Roots**”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达时，则证明此对象是不可用的，即被判定为可被回收的对象。

在Java语言中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般所说的Native方法）引用的对象

3. **回收方法区**

在方法区进行垃圾收集的性价比比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95%的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分：**废弃常量**和**无用的类**。判定一个废弃常量比较简单，而要判定一个类是否是“无用的类”则条件相对苛刻许多。类同时需要满足以下三个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是Java堆中不存在任何该类的实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

4. **垃圾收集算法**

   1. 标记-清除算法

   算法分为标记和清除两个阶段：首先标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象。存在的不足有两个，一个是效率问题，一个是空间问题。这种算法会产生大量不连续的空间碎片，这会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存。

   ![1](https://github.com/dutertk/Images/blob/master/1.jpeg?raw=trueç)

   2. 复制算法

   将可用内存按容量分为大小相等两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。但是这种算法会将内存缩小为原来的一般，代价太高。

   现在的商业虚拟机都使用这种算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1.

   ![WechatIMG2](https://github.com/dutertk/Images/blob/master/WechatIMG2.jpeg?raw=true)

   3. 标记-整理算法

   根据老年代的特点，使用标记-整理算法进行垃圾收集，标记过程同第一种一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。示意图如下：

   ![WechatIMG1](https://github.com/dutertk/Images/blob/master/WechatIMG1.jpeg?raw=true)

   **注：**第一次使用Typora上传图片，看看效果吧。

5. **垃圾收集器**

6. Serial收集器

单线程收集器，但是“单线程”并不仅仅意味着只会使用一个CPU或一条收集线程去完成垃圾收集，更重要的是在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

2. ParNew收集器

Serial收集器的多线程版本，只有它能与CMS（Concurrent Mark Sweep）收集器配合使用。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了垃圾收集与用户线程同时工作。

**并行：**多条收集线程同时运行，但用户线程仍然处于等待状态。

**并发：**垃圾收集线程与用户线程同时执行，用户线程在继续运行，而垃圾收集线程运行与另一个CPU上。

3. Parallel Scavenge收集器

新生代收集器，使用复制算法进行收集。特点是关注点与其他收集器不同，CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而这款收集器则是达到一个可控制的吞吐量。

**吞吐量：**用户运行代码的时间/(用户运行代码的时间+垃圾收集的时间)

4. CMS收集器

是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法实现，分为以下4个步骤

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

初始标记仅仅是标记以下GC Roots能直接关联到的对象，速度很快，并发标记阶段就进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。优点是并发收集、低停顿。缺点：

- 对CPU资源非常敏感
- 无法清理浮动垃圾
- 收集结束会有大量内存碎片产生

5. G1(Garbage-First)收集器

特点：

- 并行与并发：能充分利用多CPU、多核环境下的优势，使用多个CPU来缩短stop-the-world停顿的时间
- 分代收集：分代概念在G1收集器中仍然保留
- 空间整合：不管是基于“标记-整理”算法还是局部的基于“复制”算法，保证了G1运行期间不会产生内存空间碎片。
- 可预测的停顿

G1收集器将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分region的集合。G1之所以能预测停顿时间模型，是因为它有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所用的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。